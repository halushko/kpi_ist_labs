# VACUUM

В даный лабораторній роботі розглянеться використання одного з хінтів (hints) - використання VACUUM 
“хінти” — неформальна добірка прийомів, які допоможуть “спонукати” PostgreSQL обирати кращі плани. У чистій СУБД немає офіційних директив, зате є конфігураційні параметри, аналітика (EXPLAIN) та методи переписування запитів (поради як правильно писати запити). 
Ви також можете використовувати підказки оптимізатору вставляючи їх прямо у ваш запит (наприклад, “IndexScan(table index)” - pg_hint_plan.
Однак зважте, що найбільш “ідеологічний” підхід PostgreSQL — виправити структуру даних, індекси та статистику, щоб оптимізатор сам робив правильний вибір без ваших підказок.

## Теорія 

VACUUM у PostgreSQL – це спеціальна операція, яка «прибирає» в таблицях (і відповідних індексах) непотрібні або застарілі версії рядків (кортежів). Через механізм MVCC (Multiversion Concurrency Control) у PostgreSQL видалені чи оновлені рядки не зникають моментально з файлів бази, а лишаються там як “неактуальні” версії, недоступні для майбутніх транзакцій (якщо ці транзакції почалися пізніше відповідних змін).
VACUUM допомагає:
1. Звільняти простір
   1. Видаляє фізично непотрібні дані (мертві рядки), роблячи сторінки таблиці знову придатними для запису нових рядків.
   2. Без VACUUM база з часом може “розростатися” через накопичення застарілих версій.
2. Оновлювати статистику видалених рядків (у разі опції VACUUM ANALYZE)
   1. ANALYZE додатково оновлює статистику розподілу даних у таблицях, що впливає на вибір плану оптимізатором.
3. Підтримувати систему від “wraparound”
   1. Кожна транзакція у PostgreSQL має власний ідентифікатор (xid). Якщо тривалий час не виконувати VACUUM, велика кількість “старих” даних може призвести до переповнення xid, що загрожує “wraparound” (коли лічильник транзакцій заходить на нове коло). VACUUM у процесі “прибирає” дані, вже непотрібні новим транзакціям, у тому числі застарілі xid.

### Як працює MVCC у PostgreSQL
Замість того щоб блокувати рядки при оновленні або видаленні, PostgreSQL використовує версії рядків (multiversion):
1. INSERT – створює новий рядок з унікальним ідентифікатором транзакції (xid).
2. UPDATE – не змінює рядок напряму, а створює нову версію (старий рядок позначається як "мертвий").
3. DELETE – просто позначає рядок як невидимий для нових транзакцій, але фізично не видаляє його одразу.

Таким чином, кожна транзакція бачить “знімок” (snapshot) даних, який був актуальним на момент її старту.
Як же тоді PostgreSQL визначає “актуальність” рядка? Кожен рядок містить технічні метадані:
1. xmin – ID транзакції, яка створила рядок.
2. xmax – ID транзакції, яка видалила або оновила рядок (якщо NULL – рядок ще актуальний).

Коли транзакція читає дані, вона використовує ці поля: 
1. Бачить тільки ті рядки, у яких xmin ≤ поточна транзакція.
2. Ігнорує рядки, у яких xmax вже встановлено (тобто інша транзакція їх змінила або видалила).

Переваги MVCC
1. Читання не блокує запис, а запис – читання.
2. Висока продуктивність при паралельних запитах (немає “глобального” блокування).
3. Ізоляція рівня READ COMMITTED і REPEATABLE READ працює без “конфліктів”.

Недоліки та обслуговування
1. Мертві рядки накопичуються, бо PostgreSQL не видаляє їх одразу.
2. VACUUM потрібен, щоб прибирати “мертві” версії рядків та очищати простір.
3. Autovacuum має бути налаштований, щоб запобігти зайвому розростанню бази.

### Основні різновиди VACUUM
1. VACUUM [TABLE]
   1. Найпростіша форма: виконує прибирання “мертвих” рядків, роблячи простір у файлі таблиці (і частково індексах) придатним для повторного використання.
2. VACUUM FULL
   1. Більш радикальний режим: блокує таблицю для читання й запису, перепаковує файли цілком, віддаючи “вільний” простір назад файловій системі.
   2. Під час “VACUUM FULL” створюється новий фізичний файл таблиці, а старий видаляється після завершення. Використовувати варто рідко (коли таблиця значно “роздута”).
3. VACUUM FREEZE
   1. У термінах PostgreSQL (зокрема, автоматичного “autovacuum”) freeze (“заморожування”) xid відбувається, коли рядок став “досить старим”, і треба запобігти wraparound.
   2. Це означає, що рядки з великим “віком” транзакції позначаються “замороженими” (frozen), щоб їх можна було вважати “вічно валідними” для будь-яких нових транзакцій.
4. ANALYZE
   1. Можна об’єднати з VACUUM: VACUUM ANALYZE table_name;
   2. Збирає статистику (кількість рядків, розподіл за стовпцями) для використання планувальником запитів.

### Підсумок
Отже, VACUUM – це “прибирання” непотрібних рядків у таблицях PostgreSQL, необхідне через модель MVCC. Він повертає сторінки у “вільний простір”, щоб ці сторінки могли бути повторно використані для нових даних, тим самим запобігаючи нестримному зростанню файлів бази. У більшості випадків PostgreSQL робить це автоматично (autovacuum), але інколи потрібне ручне втручання — особливо, якщо є великі масові видалення або критичний ризик wraparound.
1. Якщо у вас велика кількість оновлень (UPDATE) – варто налаштувати автовакуум (autovacuum).
2. Якщо DELETE виконується масово, а таблиця “розростається”, може знадобитися VACUUM FULL (але це блокує таблицю).
3. Якщо транзакції “зависають”, старі версії даних не видаляються – слід перевірити pg_stat_activity.

