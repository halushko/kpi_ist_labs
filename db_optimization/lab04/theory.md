# Формальні та неформальні хінти для оптимізації SELECT-запитів

Хінти можна розбити на дві групи: ті, які напряму вставляються в SQL запит типу "`/*+ IndexScan(...) */`" (pg_hint_plan ) та вплив через налаштування БД, структуру самого запиту, статистику.
Формальні хінти застосовуються лише до окремого запиту, тому якщо, наприклад, вам треба скрізь використовувати не BitMap, а Seq Scan, то ви можете налаштувати БД таким чином через неформальні хінти.
І не повторювати в кожному своєму запиті відповідні формальні хінти. 
Взагалі, під час підготовки лаби стикнувся з проблемою - як її назвати. Бо назв хінтам доволі багато. Тому просто перелічу деякі найкращі варіанти:
1. Формальні та неформальні хінти
2. Прямі та непрямі хінти
3. Явні та імпліцитні хінти
4. Хардові та м’які хінти
5. Хінти рівня SQL і хінти рівня налаштувань

Обирайте що вам більше до душі

Тепер до самої суті. В цій лабораторній роботі ми розглянемо декілька прикладів використання хінтів. По-перше, самих хінтів існує дуже багато, всіх перелічувати не буду.
По-друге, в переліку розіб'ю хінти за приблизними категоріями. Приклади хінтів у [цьому фійлі](https://github.com/halushko/kpi_ist_labs/blob/7ead580da3bf08892d5b217b0a3c0d58e8bdafc6/db_optimization/lab04/postgresql_hints.md) 

## 1. Що таке хінти (hints) у PostgreSQL
PostgreSQL не має вбудованої системи хінтів, як Oracle або MySQL. Проте існують способи непрямо або явно впливати на планувальник запитів:
1. Непрямі хінти:
   1. Вимикання певних типів сканування: SET enable_seqscan = off;
   2. Зміна cost-параметрів: random_page_cost, seq_page_cost
   3. Переписування запиту для більш ефективної оптимізації
2. Прямі хінти (через розширення pg_hint_plan):
   1. Дають змогу вставляти хінти в SQL-коментарі:
   2. Потрібно підключити розширення pg_hint_plan

## 2. Типи сканування таблиць
Просто нагадаю з попередньої лаби:<br><br>
**Seq Scan** (послідовне сканування) – читає всю таблицю. Використовується, коли немає індексу або вибірка дуже велика.<br>
**Index Scan** – шукає рядки за індексом. Добре працює на високоселективних умовах (WHERE id = ...).<br>
**Bitmap Index Scan** + **Bitmap Heap Scan** – комбінований метод, ефективний при вибірці кількох відсотків рядків.<br>
**Index Only Scan** – працює повністю з індексу, без доступу до таблиці, якщо всі потрібні поля вже є в індексі.<br>

## 3. Типи JOIN і вплив хінтів
PostgreSQL має три фізичні методи виконання JOIN:<br><br>
**Nested Loop Join** – ефективний при малому обсязі даних або наявності індексу на внутрішній таблиці.<br>
**Hash Join** – ефективний при з’єднанні великих таблиць без індексів.<br>
**Merge Join** – вимагає попереднього сортування, але дуже швидкий при злитті відсортованих джерел.<br>


## 4. OR -> UNION ALL

Це неформальний хінт, який виступає як рекомендація. Коли OR використовується в операторі WHERE, планувальник операцій може піти неефективним шляхом. 
Хорошою практикою є заміна OR на UNION/UNION ALL вручну у певних випадках.

### “UGLY” OR

Справді небажаним використання OR може стати у випадку з об’єднанням декількох таблиць (або інстанцій однієї) і використанням умов на стовпці **з різних таблиць**. 
Тоді оптимізатор не може ефективно застосовувати індекси. Цьому можна запобігти з використанням UNION/UNION ALL. 
При роботі з реальними даними прискорення може бути дуже суттєвим.

```postgresql
SELECT e.name, e.salary, d.department_name, d.location
FROM employees e
JOIN departments d ON e.department_id = d.department_id
WHERE e.salary > 70000 OR d.location == 'Chicago';
```

Якщо salary і location проіндексовані, доцільно розділити цей запит на два окремих:

```postgresql
SELECT e.name, e.salary, d.department_name, d.location
FROM employees e
JOIN departments d ON e.department_id = d.department_id
WHERE e.salary > 70000

UNION

SELECT e.name, e.salary, d.department_name, d.location
FROM employees e
JOIN departments d ON e.department_id = d.department_id
WHERE d.location == 'Chicago';
```

Якщо дублікати не очікуються або ними можна знехтувати, то UNION можна замінити на ще більш ефективний UNION ALL.
З UNION ALL базі даних не потрібно виконувати сортування і перевірку на дублікати, що значно прискорює виконання запиту.

Чому оптимізатор PostgreSQL не може автоматично трансформувати такі запити? Розглянемо наступний випадок:

```postgresql
CREATE TABLE a (
   id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
   x integer,
   p integer
);

CREATE TABLE b (
   id integer GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
   x integer,
   q integer
);

INSERT INTO a (x, p) VALUES
   (1, 1),
   (1, 1),
   (2, 1);

INSERT INTO b (x, q) VALUES
   (1, 3),
   (2, 3);
```

```postgresql
SELECT x, a.p, b.q
FROM a JOIN b USING (x)
WHERE a.p = 1 OR b.q = 3;
```

| x | p | q |
|---|---|---|
| 1 | 1 | 3 |
| 1 | 1 | 3 |
| 2 | 1 | 3 |

Отримаємо бажаний результат з OR. Проте, якщо використати UNION, дублікати (де значення всіх стовпців однакові) будуть видалені:

```postgresql
SELECT x, a.p, b.q
FROM a JOIN b USING (x)
WHERE a.p = 1
UNION
SELECT x, a.p, b.q
FROM a JOIN b USING (x)
WHERE b.q = 3;
```

| x | p | q |
|---|---|---|
| 1 | 1 | 3 |
| 2 | 1 | 3 |

UNION ALL включить рядки, що задовільняють обом умовам, двічі.

| x | p | q |
|---|---|---|
| 1 | 1 | 3 |
| 1 | 1 | 3 |
| 2 | 1 | 3 |
| 1 | 1 | 3 |
| 1 | 1 | 3 |
| 2 | 1 | 3 |

Отже, проблема в тому, що оптимізатор не може визначити, яка дублікація хороша, а яка - погана.
Тому такі перетворення потрібно робити вручну, зважаючи на структуру таблиць й повернених з запиту даних.

### “BAD” OR

Об’єднання через OR умов у межах однієї таблиці зазвичай не є проблемним. Оптимізатор може знайти спосіб застосувати індекси за стовпцями, зазначеними у WHERE. 
Для певних таблиць може бути покращення з UNION ALL, коли умови мають різну вибірковість, чи одна з них не може задіяти індекси.

У випадках, коли є декілька умов на той же стовпець, найліпше використати IN. Сучасні бази даних забезпечують додаткову оптимізацію запитів з цим оператором завдяки хешуванню значень чи обробці порціями.

```postgresql
SELECT id, first_name
FROM employees e
WHERE e.id IN (473, 988, 1654);
```

### “GOOD” OR

Вираз CASE виконується після вибірки рядків, тому OR у ньому не впливає на продуктивність.

## 5. Додатково хотів би розказати
### 4.1. Пильнуйте параметр work_mem (особливо для Hash Join, сортувань)
**work_mem** визначає, скільки пам’яті можна використовувати для сортувань та хешування. Якщо запити “розливаються” (spill) на диск, це сповільнює JOIN, сортування або агрегації.<br>
Якщо бачите у EXPLAIN ANALYZE повідомлення про “external merge” або “disk-based hash”:
```postgresql
SET work_mem = '256MB';
```
Значення підбирайте уважно, щоб не перевищити загальні ресурси

## 4.2. Іноді корисна денормалізація або партиціювання
Хоча норми БД (I, II, III нормальні форми) – це добре, але іноді денормалізація (дублювання даних) або партиціювання великої таблиці (partitioning) значно покращує запити.<br>
Таблиця з мільйонами рядків, при цьому 95% запитів фільтрують за датою → Range Partition за датою дозволить “пропускати” непотрібні партиції.<br>
Якщо часто JOIN-ують невелику довідникову таблицю, можна інколи “приєднати” її колонки без JOIN (залежить від сценарію).<br>

## 4.3. Перевіряйте план виконання (EXPLAIN та EXPLAIN ANALYZE)
Головний “хінт”: без аналізу планів ви не знатимете, чому БД так працює. EXPLAIN показує очікувані витрати, а EXPLAIN ANALYZE — реальні часи та кількість рядків.
Можете використовувати коли э підозра, що запит повільний. Увага, виконання важких запитів може погано сказатися на продуктивності. Для тесту/навчання краще використовуйте якісь не занадто "важкі" SELECT, але це лише на ваш розсуд
```postgresql
EXPLAIN (ANALYZE, BUFFERS)
SELECT ...
```
Дивимося, де “rows” і “actual rows” сильно відрізняються, який JOIN-метод обраний, скільки “buffers read” тощо - це допоможе вам зрозуміти, які хіти краще використати для оптимізації запиту