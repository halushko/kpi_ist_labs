# Формальні та неформальні хінти для оптимізації SELECT-запитів

Хінти можна розбити на дві групи: ті, які напряму вставляються в SQL запит типу "`/*+ IndexScan(...) */`" (pg_hint_plan ) та вплив через налаштування БД, структуру самого запиту, статистику.
Формальні хінти застосовуються лише до окремого запиту, тому якщо, наприклад, вам треба скрізь використовувати не BitMap, а Seq Scan, то ви можете налаштувати БД таким чином через неформальні хінти.
І не повторювати в кожному своєму запиті відповідні формальні хінти. 
Взагалі, під час підготовки лаби стикнувся з проблемою - як її назвати. Бо назв хінтам доволі багато. Тому просто перелічу деякі найкращі варіанти:
1. Формальні та неформальні хінти
2. Прямі та непрямі хінти
3. Явні та імпліцитні хінти
4. Хардові та м’які хінти
5. Хінти рівня SQL і хінти рівня налаштувань

Обирайте що вам більше до душі

Тепер до самої суті. В цій лабораторній роботі ми розглянемо декілька прикладів використання хінтів. По-перше, самих хінтів існує дуже багато, всіх перелічувати не буду.
По-друге, в переліку розіб'ю хінти за приблизними категоріями. Приклади хінтів у [цьому фійлі](postgresql_hints.md) 

## 1. Що таке хінти (hints) у PostgreSQL
PostgreSQL не має вбудованої системи хінтів, як Oracle або MySQL. Проте існують способи непрямо або явно впливати на планувальник запитів:
1. Непрямі хінти:
   1. Вимикання певних типів сканування: SET enable_seqscan = off;
   2. Зміна cost-параметрів: random_page_cost, seq_page_cost
   3. Переписування запиту для більш ефективної оптимізації
2. Прямі хінти (через розширення pg_hint_plan):
   1. Дають змогу вставляти хінти в SQL-коментарі:
   2. Потрібно підключити розширення pg_hint_plan

## 2. Типи сканування таблиць
Просто нагадаю з попередньої лаби:<br><br>
**Seq Scan** (послідовне сканування) – читає всю таблицю. Використовується, коли немає індексу або вибірка дуже велика.<br>
**Index Scan** – шукає рядки за індексом. Добре працює на високоселективних умовах (WHERE id = ...).<br>
**Bitmap Index Scan** + **Bitmap Heap Scan** – комбінований метод, ефективний при вибірці кількох відсотків рядків.<br>
**Index Only Scan** – працює повністю з індексу, без доступу до таблиці, якщо всі потрібні поля вже є в індексі.<br>

## 3. Типи JOIN і вплив хінтів
PostgreSQL має три фізичні методи виконання JOIN:<br><br>
**Nested Loop Join** – ефективний при малому обсязі даних або наявності індексу на внутрішній таблиці.<br>
**Hash Join** – ефективний при з’єднанні великих таблиць без індексів.<br>
**Merge Join** – вимагає попереднього сортування, але дуже швидкий при злитті відсортованих джерел.<br>

## 4. Додатково хотів би розказати
### 4.1. Пильнуйте параметр work_mem (особливо для Hash Join, сортувань)
**work_mem** визначає, скільки пам’яті можна використовувати для сортувань та хешування. Якщо запити “розливаються” (spill) на диск, це сповільнює JOIN, сортування або агрегації.<br>
Якщо бачите у EXPLAIN ANALYZE повідомлення про “external merge” або “disk-based hash”:
```postgresql
SET work_mem = '256MB';
```
Значення підбирайте уважно, щоб не перевищити загальні ресурси

## 4.2. Іноді корисна денормалізація або партиціювання
Хоча норми БД (I, II, III нормальні форми) – це добре, але іноді денормалізація (дублювання даних) або партиціювання великої таблиці (partitioning) значно покращує запити.<br>
Таблиця з мільйонами рядків, при цьому 95% запитів фільтрують за датою → Range Partition за датою дозволить “пропускати” непотрібні партиції.<br>
Якщо часто JOIN-ують невелику довідникову таблицю, можна інколи “приєднати” її колонки без JOIN (залежить від сценарію).<br>

## 4.3. Перевіряйте план виконання (EXPLAIN та EXPLAIN ANALYZE)
Головний “хінт”: без аналізу планів ви не знатимете, чому БД так працює. EXPLAIN показує очікувані витрати, а EXPLAIN ANALYZE — реальні часи та кількість рядків.
Можете використовувати коли є підозра, що запит повільний. Увага, виконання важких запитів може погано сказатися на продуктивності. Для тесту/навчання краще використовуйте якісь не занадто "важкі" SELECT, але це лише на ваш розсуд
```postgresql
EXPLAIN (ANALYZE, BUFFERS)
SELECT ...
```
Дивимося, де “rows” і “actual rows” сильно відрізняються, який JOIN-метод обраний, скільки “buffers read” тощо - це допоможе вам зрозуміти, які хіти краще використати для оптимізації запиту
