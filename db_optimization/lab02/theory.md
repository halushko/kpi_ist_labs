# Explain Plan
## Операції (Operations) 
### 1. Seq Scan
Послідовне (повне) сканування таблиці: PostgreSQL читає всі рядки з диска й застосовує фільтр (якщо він є) для відбору потрібних рядків.
### 2. Index Scan
Сканування за індексом: пошук потрібних значень (або діапазону значень) у B-Tree (чи іншому типі) індексі, отримання TID (row pointer) і доступ до відповідних рядків у таблиці.
### 3. Index Only Scan
Сканування виконується лише по індексу, без звернення до таблиці, якщо всі потрібні стовпці для запиту присутні в індексі (та немає потреби перевіряти видалені чи невидимі рядки). Зчитує дані безпосередньо з індексних сторінок.
### 4. Bitmap Index Scan
Індекс використовується для пошуку набору TID, але замість безпосереднього доступу до таблиці створюється “бітова карта” (bitmap) відповідних сторінок/рядків.
Bitmap Index Scan – це один з механізмів, який PostgreSQL використовує для сканування даних за індексом з метою прискорити вибірку значного, але не надто великого відсотку рядків у таблиці. Його назва відображає ключову ідею: замість негайного випадкового доступу до кожного знайденого рядка (як у звичайному Index Scan), PostgreSQL спочатку збирає в пам’яті список (bitmap) усіх придатних TID (вказівників на рядки), а потім зчитує ці рядки з таблиці “пакетно” у більш оптимальному порядку.
Для складних умов, коли потрібно використати декілька індексів одночасно (наприклад, WHERE colA = X AND colB = Y), план може включати “BitmapAnd” або “BitmapOr” на кілька індексів:
**Non-lossy**
Якщо повертається порівняно невелика кількість TID, PostgreSQL може зберігати точну інформацію про кожен TID. Тоді додаткова перевірка в “Bitmap Heap Scan” фактично не відкидає зайві рядки (бо їх немає).
**Lossy**
Якщо ж TID дуже багато, PostgreSQL може зберігати лише те, що певна сторінка містить “хоча б один відповідний рядок” (без точної вказівки). У такому разі під час “Bitmap Heap Scan” потрібно перечитати всі рядки зі сторінок і перевірити умову WHERE.
“Lossy” формат зберігає пам’ять і прискорює побудову bitmap, але потребує “Recheck” при скануванні сторінки.
-- **МОЖЕ** ходити по декільком індексам
Bitmap Index Scan – це ефективний спосіб сканування за індексами в тих випадках, коли не варто робити простий Index Scan через велику кількість “цільових” рядків, але й не варто робити Seq Scan, бо не вся таблиця потрібна.
Результатом цього механізму є зниження випадкового читання, адже PostgreSQL групує доступ до сторінок таблиці, використовуючи бітову структуру.
Часто Bitmap Index Scan з’являється в планах, де одночасно використовуються декілька індексів (BitmapAnd, BitmapOr) для складніших умов.
Для отримання оптимальної роботи варто стежити за актуальністю статистики, розміром work_mem, а також не забувати про коректне налаштування вартості дискових операцій (random_page_cost, seq_page_cost).
Загалом, Bitmap Index Scan – це “золота середина” між надмірно дрібнозернистим “Index Scan” та повним “Seq Scan” у тих сценаріях, де PostgreSQL очікує обробити значну кількість рядків, але все ж меншу, ніж майже вся таблиця. Це дозволяє ефективно використовувати індекси й одночасно мінімізувати “розкидані” звернення до диска.
У вкладеному “Bitmap Index Scan”
cost здебільшого пов’язаний із проходженням по індексу, побудовою/об’єднанням бітових карт (зокрема, якщо є BitmapAnd/BitmapOr).
rows – оціночна кількість TID, які поверне індекс.
### 5. Bitmap Heap Scan
Після отримання бітової карти (Bitmap Index Scan) PostgreSQL сканує потрібні сторінки таблиці у довільному порядку, однак об’єднує звернення до однієї сторінки для кількох рядків (зменшує random I/O).
Recheck Cond означає, що PostgreSQL на рівні heap-сторінки ще раз перевірить умову WHERE. Це потрібно у випадку, коли бітова карта була “lossy” або коли індекс не гарантує точної відповідності (наприклад, GiST чи інший “approximate” індекс).
Якщо бітова карта “lossy” (тобто зберігає лише інформацію про те, що “в цьому блоці можливо є придатні рядки”), то при “Bitmap Heap Scan” може виявитися, що не всі рядки в цьому блоці справді відповідають умові. Тоді ці рядки будуть відфільтровані під час “Recheck Cond”.
Якщо бітова карта “non-lossy” (позначає точні TID), “Recheck Cond” може нічого не відсіяти, бо всі відмічені рядки справді підходять.
Це дає змогу об’єднувати кілька умов, індексів або зберігати карту TID у стислому вигляді, не втрачаючи коректності результату.
“Recheck Cond” – додатковий крок захисту від “хибних спрацювань”, характерних для “lossy” підходу.
Переваги і сценарії застосування
Пакетне зчитування
Головна перевага у тому, що PostgreSQL намагається групувати читання сторінок таблиці, а не “стрибати” навмання для кожного рядка. Це особливо вигідно на дисках із високою вартістю випадкового доступу (наприклад, HDD).
Середня селективність
Коли умова повертає достатньо великий обсяг рядків, але не понад 30–50% таблиці, “bitmap scan” (комбо Bitmap Index Scan + Bitmap Heap Scan) часто стає “золотою серединою” між звичайним “Index Scan” і повним “Seq Scan”.
Об’єднання індексів
Якщо у запиті декілька умов на різні стовпці (AND, OR), PostgreSQL може створювати бітові карти з кількох індексів і комбінувати їх через BitmapAnd або BitmapOr. У підсумку “Bitmap Heap Scan” піде вже за злитим набором TID.
У “Bitmap Heap Scan”
cost відображає витрати на зчитування сторінок таблиці та повторну перевірку рядків.
rows – це оціночна кількість рядків, які залишаться після “Recheck Cond”.
### 6. Tid Scan
Звертається безпосередньо до рядків за вказаними TID (table identifier). Зустрічається рідко, зазвичай у спеціальних випадках або якщо TID використовується явно в запиті.
### 7. Subquery Scan
Сканування результатів підзапиту, тобто PostgreSQL виконує спочатку внутрішній запит, зберігає результат як “тимчасову таблицю в пам’яті” (підплан), а потім сканує її.
### 8. Function Scan
Виконує сканування набору, повернутого функцією (set-returning function). Наприклад, якщо ви викликаєте функцію, що повертає таблицю.
### 9. Values Scan
Сканує “інлайн-таблицю” з конструкції VALUES(...) у запиті.
Простий SELECT із VALUES
EXPLAIN
SELECT *
FROM (VALUES (1, 'a'), (2, 'b'), (3, 'c')) AS t(id, val);
Особливості та переваги Values Scan
Швидко і просто

VALUES(...) — це статичний набір рядків, його не потрібно читати з диска чи застосовувати індекс. Усе є у пам’яті під час виконання плану.
Застосовується для коротких переліків

Найчастіше використовується, щоб:
Згенерувати невелику “таблицю” для перевірки (схоже на “mock data”).
Швидко вставити декілька рядків за допомогою INSERT ... SELECT.
Використовувати у запитах типу WITH some_cte AS (VALUES(...)) SELECT ....
Може повертати кілька стовпців

Конструкція VALUES (col1, col2, ...), (col1, col2, ...) може створювати одразу кілька стовпців.
У плані ви можете присвоїти псевдоніми:
sql
Копіювати
Редагувати
VALUES (1, 'a'), (2, 'b'), (3, 'c') as t(id, val)
Кількість рядків

Якщо ви передаєте тисячі (або мільйони) значень у VALUES(...), це стає менш практичним (і може сповільнити парсинг запиту), але технічно все одно буде Values Scan.
У реальних сценаріях, якщо обсяг даних великий, частіше застосовують тимчасові таблиці, CTE або файли імпорту.
**Немає “Recheck Cond”, “Index Cond”**
Оскільки це статичні дані, у плані не буде умов індексного доступу, фільтра тощо (якщо тільки ви не накладаєте додаткові WHERE-умови зверху).
Якщо ви все ж робите фільтр, це буде виглядати як окремий крок (наприклад, “Filter”) після Values Scan.
### 10. CTE (Common Table Expression) Scan
Сканування даних, отриманих зі CTE WITH ... AS (...). Результат CTE зберігається тимчасово, а потім сканується.
WITH cte_name AS (
  SELECT ...
  FROM ...
  WHERE ...
)
SELECT *
FROM cte_name;
У старіших версіях (до PostgreSQL 12) CTE завжди виконувався, наче це був ізольований запит: CTE обчислювався повністю і зберігався (materialized) перед виконанням основного запиту. Це впливало на оптимізацію, бо планувальник не “провалювався” в CTE, щоб змінити його план під контекст основного запиту.
Починаючи з PostgreSQL 12, є “inline CTE” (з певними умовами) — у деяких випадках запит із CTE може бути оптимізований “більш агресивно”, а CTE не завжди materialize-иться повністю. Проте, якщо CTE використовується кілька разів або позначений як MATERIALIZED, його результат таки зберігається тимчасово, й тоді у плані бачимо CTE Scan.
(Коли PostgreSQL обчислює WITH cte_name AS (subquery), результат зберігається у проміжній структурі (tuplestore) або аналогічному механізмі.
Після того, коли потрібно звернутися до cte_name, планувальник вставляє у дерево плану вузол CTE Scan, який “сканує” цей збережений набір рядків.)
Зручність та чистота коду
CTE робить складні запити більш читабельними, дає змогу логічно розділити підзапити.
Одноразове обчислення
Якщо cte_name використовується кілька разів, результати підзапиту обчислюються єдиний раз (у матеріалізованій формі).
 Недоліки (особливо до PostgreSQL 12)
Матеріалізація

До 12-ї версії PostgreSQL (або коли використовується MATERIALIZED), CTE завжди повністю обчислюється, навіть якщо підзапит (теоретично) міг би бути оптимізований у “inline” або навіть у “можливо не виконуватися”.
Відсутність “pushing down” умов

Запит, який звертається до CTE, зазвичай не може “продавлювати” умови фільтра (WHERE) назад у CTE (у старіших версіях). Тобто CTE виконується повністю, і лише тоді обробляється фільтр.
Це може привести до менш ефективних планів порівняно з “inline” підзапитами.
Додаткові витрати пам’яті/диска

Збереження результатів CTE (особливо якщо вони великі) може вимагати суттєвих ресурсів (у work_mem або на диску), це може уповільнити виконання складних запитів.

Починаючи з PostgreSQL 12

Якщо хочете, щоб CTE завжди виконувався окремо і зберігався (а не “inline”), можна додати ключове слово MATERIALIZED:
WITH cte_name AS MATERIALIZED (
  SELECT ...
)
SELECT ...
Якщо бажаєте, щоб планувальник мав право “розвернути” CTE у “inline” і оптимізувати його разом з основним запитом, пишіть WITH cte_name AS NOT MATERIALIZED (...) або просто не вказуйте нічого й покладайтесь на автоматичне поводження планувальника (за замовчуванням NOT MATERIALIZED у PostgreSQL 12+).
Стежте за обсягом даних
Якщо CTE повертає велику кількість рядків, перевіряйте, скільки work_mem виділено, чи не відбувається сповзання в “disk spill”. Це може суттєво впливати на продуктивність.
Порівнюйте з альтернативами
Іноді замість CTE краще використати підзапит у FROM або навіть JOIN, щоб дозволити оптимізатору поширювати умови фільтра.
У деяких випадках (особливо до PostgreSQL 12) можна побачити виграш, якщо переписати CTE на підзапит, щоб уникнути матеріалізації.

### 11. WorkTable Scan
Застосовується під час рекурсивних запитів (наприклад, WITH RECURSIVE). “Work table” – це внутрішня структура для ітераційного збирання результатів.
11.1. Named Tuplestore Scan / Foreign Scan / Sample Scan 
11.2. Named Tuplestore Scan: доступ до раніше збереженого набору кортежів під назвою.
11.3 Foreign Scan: сканування “іноземної” (foreign) таблиці через FDW (Foreign Data Wrapper).
11.4 Sample Scan: виконує статистичне вибіркове сканування таблиці (наприклад, системна або бернуллійська вибірка).